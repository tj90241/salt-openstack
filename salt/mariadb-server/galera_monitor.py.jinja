{%- set consul_site = pillar['consul']['site'] -%}
{%- set domain = consul_site['domain'] -%}
{%- set role = 'server' if grains.fqdn in consul_site['server_fqdns'] else 'client' -%}
#!/usr/bin/env python3

import http.client as httplib
import http.server
import json
import logging
import logging.handlers
import pymysql
import socketserver
import socket
import ssl
import threading
import time
import urllib
from urllib import request as urllib2


# Configure logging
LOG = logging.getLogger(__name__)
LOG.setLevel(logging.INFO)
handler = logging.handlers.RotatingFileHandler("/var/log/galera_monitor.log",
                                               maxBytes=1024*1024,
                                               backupCount=7)
formatter = logging.Formatter("%(asctime)s [%(levelname)s]: %(message)s")
handler.setFormatter(formatter)
LOG.addHandler(handler)


class ConsulHTTPSConnection(httplib.HTTPSConnection):
    """
    Class which extends a httplib.HTTPSConnection and includes the Consul
    certificate chain and cert/key when connections are formed.
    """
    def __init__(self, consul_host, **kwargs):
        self.ca_certs = "/etc/consul/{{ domain }}-agent-ca.pem"
        self.cert_file = "/etc/consul/{{ role }}-{{ domain }}.pem"
        self.key_file = "/etc/consul/{{ role }}-{{ domain }}-key.pem"

        super(ConsulHTTPSConnection, self).__init__(consul_host, 8501,
                                                    key_file=self.key_file,
                                                    cert_file=self.cert_file,
                                                    timeout=kwargs["timeout"])

    def connect(self):
        sock = socket.create_connection((self.host, self.port), self.timeout)

        self.sock = ssl.wrap_socket(sock, 
            keyfile = self.key_file, 
            certfile = self.cert_file,
            ca_certs = self.ca_certs,
            ciphers = "HIGH",
            cert_reqs = ssl.CERT_REQUIRED,
            ssl_version = ssl.PROTOCOL_TLSv1_2
        )


class ConsulHTTPSHandler(urllib2.HTTPSHandler):
    """
    Class which implements a urllib2.HTTPSHandler which returns connections
    using ConsulHTTPSConnection instead of httplib.HTTPSConnection.
    """
    def __init__(self, consul_host):
        self.consul_host = consul_host
        super(ConsulHTTPSHandler, self).__init__()

    def https_open(self, req):
        # Rather than pass in a reference to a connection class, we pass in
        # a reference to a function which, for all intents and purposes,
        # will behave as a constructor.
        return self.do_open(self.get_connection, req)

    def get_connection(self, _, timeout=10):
        return ConsulHTTPSConnection(self.consul_host, timeout=timeout)


def make_consul_request(opener, url, headers={}, method="GET",
                        data=None, timeout=10):
    """
    Makes an consul API request to the specified URI with the specified HTTP
    method returns the resulting document.  Headers will always include
    "Accept: application/json" if data is supplied unless explicitly overriden.

    The cacert, cert, and key are assumed to be the same as the defaults that
    Consul itself uses for the node.
    """
    endpoint = "https://localhost:8501"
    headers["Accept"] = "application/json; charset=utf-8"
    headers["X-Consul-Token"] = "{{ pillar['consul']['token'].strip() }}"

    if data is not None:
        headers["Content-Type"] = "application/json; charset=utf-8"

        if not isinstance(data, bytes):
            data = json.dumps(data).encode("utf-8")

    request = urllib2.Request(endpoint + url, headers=headers, data=data)
    request.get_method = lambda: method

    connection = opener.open(request, timeout=timeout)
    return json.loads(connection.read().decode("utf-8")), connection.headers


def galera_sync_check(connection=None, reuse_connection=False):
    """
    Function which attempts to connect to the Galera cluster via the local
    MySQL socket and verifies that it is in a synchronized state. If it can
    connect to the local socket and the cluster is synchronized True is
    returned. Otherwise, False is returned.
    """
    try:
        if connection is None:
            socket_path = "/var/run/mysqld/mysqld.sock"
            connection = pymysql.connect(unix_socket=socket_path,
                                         db="information_schema",
                                         charset="utf8mb4",
                                         cursorclass=pymysql.cursors.DictCursor,
                                         connect_timeout=1, read_timeout=1,
                                         write_timeout=1)

        with connection.cursor() as cursor:
            sql = """
            SELECT VARIABLE_VALUE
            FROM GLOBAL_STATUS
            WHERE VARIABLE_NAME = \"wsrep_local_state_comment\"
            """
            cursor.execute(sql, ())
            result = cursor.fetchone()

            g_status = result.get("VARIABLE_VALUE", "").lower().strip()
            return g_status == "synced", connection

    except pymysql.Error:
        pass

    finally:
        if connection is not None and not reuse_connection:
            connection.close()

    return False, connection


class GaleraMonitor(http.server.BaseHTTPRequestHandler):
    """
    Request handler which implements a HTTP GET method that, upon receiving a
    request, makes a connection to the local MySQL database and verifies that
    it is synchronized with the rest of the cluster. If it everything checks
    out, 200/OK is returned. Otherwise 503/SERVICE UNAVAILABLE is returned.
    """
    def do_GET(self):
        self.send_response(200 if galera_sync_check()[0] else 503)
        self.end_headers()


def consul_update_thread(thread_stop_request):
    """
    Thread which continually monitors the health of the local database and
    ensures that the session for MySQl in Consul remains coherent with
    respect to the synchronization status of the local instance.
    """
    while not thread_stop_request.is_set():
        consul_https_handler = ConsulHTTPSHandler("localhost")
        opener = urllib2.build_opener(consul_https_handler)

        try:
            session_key = "service/mysql/cluster"
            session_list_url = "/v1/session/node/{{ grains.id }}"
            sessions, _ =  make_consul_request(opener, session_list_url)
            mysql_session, found_session = None, False

            # Search for an existing MySQL session, get its UUID...
            if isinstance(sessions, list):
                for session in sessions:
                    if isinstance(session, dict):
                        if session.get("Name") == session_key:
                            mysql_session = session.get("ID")
                            found_session = isinstance(mysql_session, str)
                            break

            # Else, if no session exists, create a new session...
            if not found_session:
                session, _ = make_consul_request(opener, "/v1/session/create",
                                                data={"Name": session_key},
                                                method="PUT")

                if not isinstance(session, dict) \
                        or not isinstance(session.get('ID'), str):
                    LOG.error("consul-status-thread: New session has no ID?")
                    time.sleep(1)
                    continue

                mysql_session = session["ID"]

            LOG.debug(f"consul-status-thread: Using session: {mysql_session}")

            # Determine if the database is healthy or not:
            # If it is, acquire the session. Otherwise, release it.
            action = "acquire" if galera_sync_check()[0] else "release"
            session_url = f"/v1/kv/{session_key}?{action}={mysql_session}"
            node = {"node": "{{ grains.id }}" }
            leader, headers = make_consul_request(opener, session_url,
                                                  method="PUT", data=node)

            # If the database is not in a healthy state, we released the
            # session and should now spin until it becomes healthy. Only when
            # it does should we again attempt to contact Consul.
            if action == "release":
                LOG.debug("consul-status-thread: Wait for database health")

                while not thread_stop_request.is_set() and \
                        not galera_sync_check()[0]:
                    time.sleep(1)

                if thread_stop_request.is_set():
                    break

                LOG.info("consul-status-thread: Database becomes healthy")
                continue

            # If the database is healthy and we are leading, monitor the
            # database and report back to Consul only when we fail.
            elif leader is True:
                LOG.info("consul-status-thread: I am becoming the leader")

                # Reuse the connection in a tighter loop for rapid failure
                # detection as we are effectively leader, now.
                try:
                    _, connection = galera_sync_check(reuse_connection=True)

                    while not thread_stop_request.is_set() and \
                            galera_sync_check(connection=connection,
                                              reuse_connection=True)[0]:
                        time.sleep(0.1)

                    connection.close()

                except pymysql.Error:
                    pass

                # We are exiting or became unhealthy: update Consul.
                session_url = f"/v1/kv/{session_key}?release={mysql_session}"
                make_consul_request(opener, session_url, method="PUT")

                if thread_stop_request.is_set():
                    break

                LOG.warning("consul-status-thread: Database becomes unhealthy")
                continue

            # Someone else is the leader. We just want to monitor the session
            # to see if and when the session is released.
            else:
                session_url = f"/v1/kv/{session_key}"
                _, headers = make_consul_request(opener, session_url)

                try:
                    index = int(headers['X-Consul-Index'])
                    session_url = f"{session_url}?index={index}"

                    if index <= 0:
                        LOG.error("consul-status-thread: Index check failed")
                        time.sleep(1)
                        continue

                except (KeyError, TypeError, ValueError):
                    LOG.error("consul-status-thread: Index is malformed")
                    time.sleep(1)
                    continue

                # Poll for writes to the key very slowly.
                LOG.info("Awaiting the leader to change...")

                while headers.get('X-Consul-Index') == str(index):
                    try:
                        _, headers = make_consul_request(opener, session_url,
                                                         timeout=60)
                        LOG.debug("Observed a write to the session")
                        break

                    except socket.timeout:
                        pass

                    if thread_stop_request.is_set():
                        break

        except urllib.error.HTTPError as error:
            prelude = f"consul-status-thread: HTTPError ({error.code})"
            LOG.error(f"{prelude}: {error.reason}")

        except urllib.error.URLError as error:
            LOG.error(f"consul-status-thread: URLError: {error.reason}")

        except socket.timeout:
            LOG.error("consul-status-thread: Unexpected API timeout")

        time.sleep(1)


if __name__ == "__main__":
    LOG.info("Monitor started")

    # Start the thread which posts updates to Consul.
    thread_stop_requested = threading.Event()
    consul_thread = threading.Thread(name="consul-updater",
                                     target=consul_update_thread,
                                     args=(thread_stop_requested,),
                                     daemon=True)
    consul_thread.start()

    # Start the webserver in this thread that can be used to query status.
    with socketserver.TCPServer(("127.0.0.1", 8500), GaleraMonitor) as h:
        try:
            h.serve_forever()

        except KeyboardInterrupt:
            h.shutdown()

    thread_stop_requested.set()
    consul_thread.join()
    LOG.info("Monitor shutdown")
